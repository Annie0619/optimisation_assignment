---
title: "Simulated Annealing"
author: "Andomei Smit: SMTAND051"
date: "25/02/2025"
output:
  pdf_document:
    toc: true
    toc_depth: 2
    fig_caption: true
    keep_tex: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

```{r}
library(readxl)
```

# Garden by numbers

The aim of the project is to find the optimal cottage garden design. 

Some intro about what a cottage garden is.

Each of the techniques will be applied to solve some aspect of this optimization problem.

Colours are from the RGB model.

# Simulated Annealing

Generate the optimal solution in terms of:
1. Colour
2. Balance
3. Symmetry
4. Seasonal variate

Constraints:
1. The height of the plants around the water feature needs to be at least 10cm shorter than the water feature
2. Tall plants cannot hide short plants where the view point is from the center of the garden out to the walls
3. There cannot be more than 25 unique types of plants
4. There must be at least 15 unique types of plants

## Read in data

```{r sim_an_data}
# read in data
plant_data <- read_xlsx("Data/Plant data for Optimisation.xlsx")
```


## Create empty grid

```{r sim_an_empty}
# create our empty garden grid of 4 meters by 8 meters 
## (i.e 8 blocks of 50cm by 16 blocks of 50cm)

empty_grid <- matrix(NA, nrow = 8, ncol = 16)

## for those blocks that are populated with either lawn, pathway, water feature or seating area, set this as a "U" to represent "unavailable"

empty_grid[3:4, 1:5] <- "U" # garden gate and pathway
empty_grid[6:7, 3:4] <- "U" # water feature
empty_grid[4:8, 6:12] <- "U" # lawn and windows
empty_grid[3:5, 13:14] <- "U" # seating area

# visualise this
empty_grid
```

## Generate an initial solution

```{r}
# start by just assigning random plants
## amount of available blocks:
open_blocks <- length(empty_grid[empty_grid!="U"])

# create empty grid:
test_bunny <- empty_grid

# sample with replacement from the plants:
set.seed(1)
test_bunny[is.na(test_bunny)] <- sample(1:50, open_blocks, replace = TRUE)

# see if it is a viable solution
water_feature_visible <- function(candidate_grid){
  # find the plant indexes in the block around the water feature
  all_plants <- candidate_grid[5, 2:5] # the row above the water feature
  all_plants <- c(all_plants, candidate_grid[8, 2:5]) # the row below the water feature
  all_plants <- c(all_plants, candidate_grid[6:7, 2]) # the left side
  all_plants <- c(all_plants, candidate_grid[6:7, 5]) # the right side
  
  # find the heights of these plants
  heights <- plant_data$Maturity_Height[as.numeric(all_plants)]
  
  # for all plants with heights >90, random sample from those with heights <=90:
  all_plants[heights>90] <- sample(which(plant_data$Maturity_Height<=90),
                                length(heights[heights>90]), replace = TRUE)
  
  # now put these back into the grid:
  candidate_grid[5, 2:5] <- all_plants[1:4]
  candidate_grid[8, 2:5] <- all_plants[5:8]
  candidate_grid[6:7, 2] <- all_plants[9:10]
  candidate_grid[6:7, 5] <- all_plants[11:12]
  
  return(candidate_grid)
}

test_bunny # before changing
water_feature_visible(test_bunny) # after changing

test_bunny <- water_feature_visible(test_bunny)

# we see index 7 changed to 36 (height 300 to 20), 9 to 34 (height 180 to 30), 21 to 31 (height 180 to 40) and 21 to 40 (height 180 to 10) to make the water feature visible
```

### Function to check height restriction for all plants

Assumptions: for all the sections above the lawn and seating area, we will only ensure that the plant heights increase from bottom to top. Call this the top section.

Divide the top section into 3 blocks:
Block one is [1:2, 1:5]
Block two is [1:3, 6:12]
Block three is [1:2, 13:16]

```{r}
# function to fix heights given 
```


```{r all_plants_visible}
all_plants_visible <- function(candidate_grid){
  # all(diff(x) >=0)
  # top section
  ## block 1
  b1 <- candidate_grid[1:2, 1:5]
  ## block 2
  b2 <- candidate_grid[1:3, 6:12]
  ## block 3
  b3 <- candidate_grid[1:2, 13:16]
  
  # for b1 and b3, just check that they're increasing and if not, sample from plants with appropriate heights
  ## catch index of the cols that violate this
  
  # find all heights (returning matrix):
  b1_heights <- matrix(plant_data$Maturity_Height[as.numeric(b1)],
                          nrow = nrow(b1))
  # which columns in b1 violate this constraint
  b1_violate <- which(as.numeric(b1_heights[1,])
                      < as.numeric(b1_heights[2,]))
  if(length(b1_violate)>0){ # if any violate this condition
    # either pick a higher plant for the back row
    if(runif(1) < 0.5){
 
    }else{ # or pick lower plant for the front row
      
    }
    
  }
}

all_plants_visible(test_bunny)
test_bunny_heights <- as.matrix(plant_data$Maturity_Height[as.numeric(test_bunny[1:2, 1:5])], nrow =2)
matrix(as.numeric(test_bunny_heights), nrow = 2)

which(matrix(as.numeric(test_bunny_heights), nrow = 2)[1,]<matrix(as.numeric(test_bunny_heights), nrow = 2)[2,])
test_bunny
```

## Define a cost function

## Define perturbing function

## Set temperature and cooling factor

## Iterate the process
